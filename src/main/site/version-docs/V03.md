# Branch: V03
# Goals: 
* Create a very basic API layer server and test it locally
* Create a IAM Role for our API servers
* Deploy it to Elastic Beanstalk
* Verify that we can hit that beanstalk instance
* Change our Cloudfront distribution to route /api/** to that location
* Verify that we can hit the instance through the Cloudfront route
* Add a JQuery call to hit that endpoint from our webpage

## Introduction to V03
At this point you have a fully functional, easy to deploy static website serving off of S3 and Cloudfront.  This website
should have a latency of about 250ms in the US, with about three to four nines of availability and costing pennies per
month unless you are taking a lot of traffic.  Not too bad, but lets face it, you could do the same thing with about any
static website hosting service.  Time to make things real.  Time to add dynamic content, served from Elastic Beanstalk.  If
you don't know what Elastic Beanstalk is or why it is cool for deploying your API layer, start out by heading 
[here](http://aws.amazon.com/elasticbeanstalk) to get a general idea of why you would use it.

For this version we are going to start with a VERY simple 
[Spring MVC](http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html) app for your API layer
- it has only one endpoint, **/v1/info/server** that returns a JSON body containing a single item, **serverTime** with 
the current server timestamp.  It uses Spring's newer Java configuration instead of XML.

## Create a very basic API layer server and test it locally
Ok, I know I sound like a total liar now, but I'm going to break the "try it first rule" one more time, and have you
**git merge V03** now.  That will bring in the API layer sample, and update the top level POM to also reference it as
a submodule.  Like in V02, we'll step through what just happened.

After you did the merge you should see that the static-site directory didn't change at all, but you have a new directory,
**api** in the root directory.  It is important to understand that you have **2** websites here, one an API server that 
serves JSON, and another static server that serves HTML and everything else.  When we reach the point of development, we
will need to start **BOTH** tomcat servers (on different ports) if we want to do a complete test (although ideal integration
tests wouldn't **depend** on the presence of the other piece to run - they should be independent of that.  Of course,
back here in the real world they often are somewhat interdependent).

Browsing the api directory, you'll see a **src/main/java** directory.  Feel free to browse around in there.  Aside from
a boilerplate SpringMVC config found in **com.erigir.chirp.config**, you should see the file
 **com.erigir.chirp.ctrl.v1.InformationCtrl**.  Looking in there you will see the server information endpoint, and a
 **force-500** endpoint that can come in handy when testing client-side error handling.  You'll also see the file
 **com.erigir.chirp.ChirpFilter**, which if you look in it you will see that we are setting the max age header (for
 the same reason we do on the static content - we'll tweak it later) and we are setting CORS headers wide open.  If
 you don't know what CORS is, [read this](http://en.wikipedia.org/wiki/Cross-origin_resource_sharing).  We'll need 
 CORS locally at least since API will be running on a different port than the static content.  Ironically, since 
 Cloudfront is going to mount our API server on /api/** in production CORS isn't needed there!  Still,
  once you want to allow business partners to use your API you'll be glad you understand CORS.

Let's start this up and run it locally, shall we?  CD into the api directory and run **mvn tomcat7:run**.  Notice
that when it starts up it runs on ports 8081 and 8444, (http and https) so that it can run at the same time as the
static site.  Once it starts, hit **http://localhost:8081/v1/info/server** and see that you get a appropriate
JSON block.  If you hit refresh you should see the time advance as well.  If this is working, go ahead and kill the
tomcat server.


## Deploy it to Elastic Beanstalk

## Verify that we can hit that beanstalk instance

## Change our Cloudfront distribution to route /api/** to that location

## Verify that we can hit the instance through the Cloudfront route

## Add a JQuery call to hit that endpoint from our webpage


