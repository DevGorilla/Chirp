# Branch: V04
# Goals: 
* Add a JQuery call from our static page to the API
* Tweak our local development process
* Add a new feature to our API
* Deploy the new API feature

## Introduction to V04
You now have a functioning website with both dynamic and static content being served through Cloudfront.  We have the
basic plumbing done and its time to start adding features.  First, we are going to add some Javascript to make sure
the server works correctly - but to make it work locally we'll have to tweak our development process.  Then we'll add 
another feature to the API (a chirp count) and work through how we deploy new versions of the API.

## Add a JQuery call from our static page to the API

So we now have an api endpoint that can tell us the current server time.  Lets add that to our index page using
JQuery.

Open up **index.html** in the static-site directory.  Find where it says 

    <h1>Chirp</h1> 

and under that add:

    <div>Server time: <span id="serverTime">TBD</span></div>

We are going to have JQuery replace that "TBD" with the current server time.  Open up **chirp.js** and find where
it says:

    console.log("Document ready placeholder");

You can delete that line, and in its place we will add this call:

    $.ajax({
        type: "GET",
        url: "/api/v1/info/server",
        contentType: "application/json; charset=utf-8",
        success: function (res, statusText, xhr, $form) {
            $("#serverTime").html(new Date(res.serverTime));
        },
        error: function (res, statusText, xhr, $form) {
            $("#serverTime").html("<h1>Error trying to lookup time: "+statusText+"</h1>");
        },
        dataType: 'json'
    });

Let's go ahead and deploy that to our server using our Seedy command

**mvn -Daws.accessKeyId=XXX -Daws.secretKey=YYY seedy:s3-upload**

Running from the **static-site** directory, and then check out what happens by hitting **http://www.yourdomain.com/index.html**

If everything went well, you should see the server time output below the **Chirp** header.  If not, time to debug your
javascript!  Doing that is outside the scope of this document, but on Chrome I like to use **View/Developer/Javascript Console**.

## Tweak our local development process

Once we start developing in earnest we'll want to test our development locally before we push it to the production 
servers.  So lets try that out.  

Open up a command terminal and CD into the api directory, and run **mvn tomcat7:run**.  Make sure it starts 
by hitting **http://localhost:8081/api/v1/info/server**.

Open up another command terminal and CD into the static-site and run **mvn tomcat7:run**.  Make sure it starts by
hitting **http://localhost:8080/index.html**.  You should get your index page... but you'll notice that the 
server time isn't working.  What gives?  Well, when developing locally, we don't have Cloudfront doing our URL
splitting.  There are a variety of ways to deal with this, but here is how we are going to do it:

Go back to **chirp.js**.  At the top of the file (before the $(document).ready) add this:

    var hostname = location.hostname;
    var apiServerPrefix = (hostname=='localhost')?"http://localhost:8081":"";
    console.log("Using server prefix "+apiServerPrefix);

This will use our local server if we are running on localhost, and the same server otherwise.  Then, in the Ajax call replace:

    url: "/api/v1/info/server",

with

    url: apiServerPrefix+"/api/v1/info/server",

And hit refresh on your browser... it should work now!  This is the nice part about local development, changes are instantaneous.

Go ahead and deploy that version to the production server to make sure we didn't break anything (use the

**mvn -Daws.accessKeyId=XXX -Daws.secretKey=YYY seedy:s3-upload**

command in the static-site directory.  From here on in, when I say "deploy the static site to production" I'll assume you
know that is what I mean)

Hit **http://www.yourdomain.com/index.html** and make sure it still works.  If so, move on to the next step.

## Add a new feature to our API

Eventually we are going to add the ability to manipulate Chirps through our API, but for the moment we just want to 
see how to actually take new versions live.  Fortunately, Seedy also helps with this.  Lets add a new API feature, test it locally,
and then see how to push it into production.

We are going to add a service layer for chirps, and an endpoint to get to them.  Create a new directory, 
**api/src/main/java/com/erigir/chirp/service**, and in it create the file **ChirpService.java**.  In that file, lets
put this content:

    package com.erigir.chirp.service;
    
    public class ChirpService
    {
        /**
         * Returns a count of all chirps
         * @return int containing the count
         */
        public int getChirpCount()
        {
            return 0;
        }
        
    }

Now, in the file **ServiceContext.java** (under chirp/config), we need to create an instance of ChirpService, so open 
that file, and after the bean for ChirpFilter lets add:

    @Bean
    public ChirpService chirpService()
    {
        ChirpService bean = new ChirpService();
        return bean;
    }

Also we'll need to add

    import com.erigir.chirp.service.ChirpService;

At the top of the file.

And we need to expose this out through the web interface, so in **com/erigir/chirp/ctrl/v1**, lets create a file 
**ChirpCtrl.java**, with the contents:

    package com.erigir.chirp.ctrl.v1;
    
    import com.erigir.chirp.service.ChirpService;

    import org.slf4j.Logger;
    import org.slf4j.LoggerFactory;
    import org.springframework.stereotype.Controller;
    import org.springframework.web.bind.annotation.*;
    
    import javax.annotation.Resource;
    import java.util.Date;
    import java.util.Map;
    import java.util.TreeMap;
    
    @Controller
    @RequestMapping("/api/v1/chirp")
    public class ChirpCtrl {
        private static final Logger LOG = LoggerFactory.getLogger(ChirpCtrl.class);
    
        @Resource(name="chirpService")
        private ChirpService chirpService;
    
        @RequestMapping(value = "/count", method = RequestMethod.GET)
        public
        @ResponseBody int chirpCount()
        {
            return chirpService.getChirpCount();
        }
    
    }
    
Let's compile and test it.  Kill your tomcat server for the API and restart with **mvn clean package tomcat7:run**
(in general we need to sometimes restart the API server, but never the static server).  Once the server starts (and
you do any needed debugging) hit **http://localhost:8081/api/v1/chirp/count** - you should get back a 0.

## Deploy the new API feature


Congrats!  If you reached here, you are ready to move on to <a href="V05.md">Version 05</a>

